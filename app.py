import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
from supabase import create_client
import io
import logging

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

st.set_page_config(layout="wide")
st.title("üöó Registro de Carros Dedicados")

# ---------------- CONEX√ÉO COM SUPABASE ----------------
url = "https://nndurpppvlwnozappqhl.supabase.co"
key = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5uZHVycHBwdmx3bm96YXBwcWhsIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njk5NDEyMiwiZXhwIjoyMDcyNTcwMTIyfQ.HSurs6kpKXCTRwR9eJE-GbZHYr0IZCQoWIaCODNHiT8"
supabase = create_client(url, key)

# ---------------- CONFIGURA√á√ÉO DE LOGIN ----------------
usuarios = {
    "financeadm": {"senha": "Dcschv2020@", "razao": "TODOS"},
    "SRM2500123": {"senha": "ba7V1sK1fzYAgIGy", "razao": "2AR TRANSPORTES LTDA"},
    "SRM2501082": {"senha": "TbrTNBmm3E2WDi7y", "razao": "NEW EXPRESS BN LTDA."},
    "SRM2500909": {"senha": "sfgzEwAggNPsu43J", "razao": "GETLOG TRANSPORTES LTDA"},
    "leticia.lima": {"senha": "LL2025!", "razao": "TODOS"},
    "daniela.conceicao": {"senha": "DC2025!", "razao": "TODOS"},
    "paula.lacerda": {"senha": "PL2025!", "razao": "TODOS"},
    "guilherme.barbosa": {"senha": "GB2025!", "razao": "TODOS"},
    "rafael.reis": {"senha": "RR2025!", "razao": "TODOS"},
    "paula.soares": {"senha": "PS2025!", "razao": "TODOS"},
    "SRM2404167": {"senha": "bcNL6gY37UAKBG62", "razao": "WF FINGER TRANSPORTE E LOGISTICA LTDA"}
}


# ---------------- FUN√á√ïES AUXILIARES ----------------

def verificar_duplicata(razao, data, operacao):
    """
    Verifica se j√° existe registro ativo (n√£o rejeitado) para evitar duplicatas.
    Retorna: (bool: existe_duplicata, list: registros_encontrados)
    """
    try:
        query = supabase.table("registro_veiculos_calendario").select("*") \
            .eq("RAZAO_SOCIAL", razao) \
            .eq("DATA_OFICIAL", data) \
            .eq("OPERACAO", operacao) \
            .neq("STATUS", "Rejeitado")

        registros = query.execute().data or []
        return len(registros) > 0, registros

    except Exception as e:
        logger.error(f"Erro ao verificar duplicatas: {e}")
        st.error(f"‚ùå Erro ao verificar duplicatas: {e}")
        return False, []


def buscar_registros_mes(razao, primeiro_dia, ultimo_dia):
    """
    Busca todos os registros de um m√™s de uma vez (otimiza√ß√£o de performance).
    Retorna um dicion√°rio organizado por data com as opera√ß√µes registradas.
    """
    try:
        query = supabase.table("registro_veiculos_calendario").select("*") \
            .eq("RAZAO_SOCIAL", razao) \
            .gte("DATA_OFICIAL", primeiro_dia.strftime("%Y-%m-%d")) \
            .lte("DATA_OFICIAL", ultimo_dia.strftime("%Y-%m-%d"))

        registros = query.execute().data or []

        # Organizar por data e opera√ß√£o para lookup r√°pido
        registros_por_dia = {}
        for reg in registros:
            data = reg.get("DATA_OFICIAL")
            if data not in registros_por_dia:
                registros_por_dia[data] = []
            registros_por_dia[data].append(reg)

        return registros_por_dia

    except Exception as e:
        logger.error(f"Erro ao buscar registros do m√™s: {e}")
        return {}


def validar_quantidades(quantidades):
    """
    Valida se pelo menos um ve√≠culo foi registrado.
    """
    total = sum(q for q in quantidades.values() if q and q > 0)
    if total == 0:
        return False, "‚ö†Ô∏è Registre pelo menos um ve√≠culo!"
    return True, ""


def inserir_registros_batch(registros_lista):
    """
    Insere m√∫ltiplos registros de uma vez (batch insert).
    """
    try:
        if not registros_lista:
            return False, "Nenhum registro para inserir"

        supabase.table("registro_veiculos_calendario").insert(registros_lista).execute()
        return True, f"‚úÖ {len(registros_lista)} registro(s) inserido(s) com sucesso!"

    except Exception as e:
        logger.error(f"Erro ao inserir registros: {e}")
        erro_str = str(e)

        if "duplicate" in erro_str.lower() or "unique" in erro_str.lower():
            return False, "‚ùå Registro duplicado detectado!"
        else:
            return False, f"‚ùå Erro ao registrar: {erro_str}"


# ---------------- AUTENTICA√á√ÉO ----------------
if "usuario" not in st.session_state:
    st.session_state["usuario"] = None

if st.session_state["usuario"] is None:
    st.subheader("üîê Login")
    usuario = st.text_input("Usu√°rio")
    senha = st.text_input("Senha", type="password")
    if st.button("Entrar"):
        if usuario in usuarios and usuarios[usuario]["senha"] == senha:
            st.session_state["usuario"] = usuario
            st.success("‚úÖ Login realizado com sucesso!")
            st.rerun()
        else:
            st.error("‚ùå Usu√°rio ou senha inv√°lidos")
    st.stop()

usuario_logado = st.session_state["usuario"]
razao_permitida = usuarios[usuario_logado]["razao"]
st.sidebar.success(f"üë§ Usu√°rio: {usuario_logado}\nüè¢ Raz√£o: {razao_permitida}")
if st.sidebar.button("üö™ Sair"):
    st.session_state["usuario"] = None
    st.rerun()

# ---------------- CONFIGURA√á√ÉO DA APLICA√á√ÉO ----------------
razoes_sociais = [
    "2AR TRANSPORTES LTDA", "ACC SILVA MINIMERCADO", "ARMARINHOS MEGA VARIEDADES LTDA",
    "ATHLANTA LOGISTICA LTDA", "CESTLAVIE LTDA", "CLIPE LOG LOGISTICA E TRANSPORTE DE CARGAS LTDA",
    "DONALDO TRANSPORTES E LOGISTICA LTDA", "DUDU BABY LTDA", "EASY CARGO SOLUCOES",
    "ETTORE BABY COMERCIO DE CONFECCOES LTDA", "EVZEN LOGISTICA LTDA", "FORTH TRANSPORTES LTDA",
    "GABRIATO EMPORIO LTDA", "GETLOG TRANSPORTES LTDA",
    "GREEN LOG SERVICOS LOGISTICOS SUSTENTAVEIS E COMERCIO DE SUPRIMENTOS LTDA",
    "GOOD ASSESSORIA POSTAL EMBALAGENS E LOGISTICA LTDA", "HBK COMERCIO E ENVIOS DE ENCOMENDAS LTDA",
    "H&L EXPRESSO LTDA", "IMILE - ANDRE LUIZ DE SOUZA", "IMILE - EMERSON DE SOUZA VELOSO",
    "IMILE - GABRIELLA JOVINA MONTEIRO", "IMILE - JOAO VICTOR CONCEICAO LOPES",
    "IMILE - RODRIGO FREITAS CIRICO", "KIM MAGAZINE LTDA", "LOJAS MIUK LTDA",
    "MOVIDOS MODA FASHION LTDA", "NET CONECT CABOS E ACESSORIOS LTDA", "NEW EXPRESS BN LTDA.",
    "NOVALINK MT COMERCIAL LTDA", "PREST SERVI APOIO AO E-COMMERCE LTDA", "QR PHONE ASSISTENCIA TECNICA LTDA",
    "RESENSERV-RESENDE SERVICOS LTDA", "RF TRANSPORTES LTDA", "RIVILOG LTDA",
    "ROHNES TRANSPORTE E LOGISTICA EIRELI", "TEC SERVICE TRANSPORTES LTDA",
    "TEREZINHA APARECIDA PATEL SERVICOS DE LOGISTICA LTDA", "WF FINGER TRANSPORTE E LOGISTICA LTDA"
]

tipos_veiculos = ["FIORINO", "VAN", "VUC", "CARRO UTILITARIO", "AJUDANTE", "MOTO"]
operacoes = ["TIKTOK", "BENNET JEANS", "SHEIN", "NUVEMSHOP"]

# ---------------- CONFIGURA√á√ÉO DAS ABAS ----------------
usuarios_aprovacao_somente = {
    "leticia.lima", "daniela.conceicao", "paula.lacerda", "guilherme.barbosa",
    "rafael.reis", "paula.soares",
}

if usuario_logado in usuarios_aprovacao_somente:
    abas = ["Aprovacao", "Relatorio"]
elif razao_permitida == "TODOS":
    abas = ["Registro", "Relatorio", "Fluxo de Aprovacao", "Aprovacao"]
else:
    abas = ["Registro", "Relatorio", "Fluxo de Aprovacao"]

abas_objs = st.tabs(abas)
tab_dict = {nome: abas_objs[i] for i, nome in enumerate(abas)}

# ---------------- ABA REGISTRO ----------------
if "Registro" in tab_dict:
    with tab_dict["Registro"]:
        st.title("üìÖ CALEND√ÅRIO DE REGISTROS")

        # Estado inicial do calend√°rio
        hoje = datetime.now()
        if "cal_ano" not in st.session_state:
            st.session_state["cal_ano"] = max(2025, min(hoje.year, 2030))
        if "cal_mes" not in st.session_state:
            st.session_state["cal_mes"] = hoje.month
        if "data_selecionada" not in st.session_state:
            st.session_state["data_selecionada"] = None
        if "form_aberto" not in st.session_state:
            st.session_state["form_aberto"] = False

        # Cabe√ßalho com navega√ß√£o de m√™s
        col_left, col_center, col_right = st.columns([1, 6, 1])
        with col_left:
            if st.button("‚óÄÔ∏è Anterior", key="btn_prev_month"):
                ano = st.session_state["cal_ano"]
                mes = st.session_state["cal_mes"]
                prev = (datetime(ano, mes, 1) - timedelta(days=1))
                if 2025 <= prev.year <= 2030:
                    st.session_state["cal_ano"] = prev.year
                    st.session_state["cal_mes"] = prev.month
                    st.rerun()
        with col_center:
            mes_nome = datetime(st.session_state["cal_ano"], st.session_state["cal_mes"], 1).strftime("%B %Y")
            st.markdown(f"### {mes_nome.upper()}")
        with col_right:
            if st.button("Pr√≥ximo ‚ñ∂Ô∏è", key="btn_next_month"):
                ano = st.session_state["cal_ano"]
                mes = st.session_state["cal_mes"]
                next_month = (datetime(ano, mes, 28) + timedelta(days=4)).replace(day=1)
                if 2025 <= next_month.year <= 2030:
                    st.session_state["cal_ano"] = next_month.year
                    st.session_state["cal_mes"] = next_month.month
                    st.rerun()

        # Gera√ß√£o dos dias do m√™s
        ano_atual = st.session_state["cal_ano"]
        mes_atual = st.session_state["cal_mes"]
        primeiro_dia = datetime(ano_atual, mes_atual, 1)

        if mes_atual == 12:
            ultimo_dia = datetime(ano_atual, 12, 31)
        else:
            ultimo_dia = datetime(ano_atual, mes_atual + 1, 1) - timedelta(days=1)

        dias_mes = pd.date_range(primeiro_dia, ultimo_dia)

        # OTIMIZA√á√ÉO: Buscar todos registros do m√™s de uma vez
        if razao_permitida != "TODOS":
            registros_mes = buscar_registros_mes(razao_permitida, primeiro_dia, ultimo_dia)
        else:
            registros_mes = {}

        # Cabe√ßalho dias da semana
        dias_semana = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"]
        cols = st.columns(7)
        for i, dia in enumerate(dias_semana):
            cols[i].markdown(f"**{dia}**")

        # Monta calend√°rio em linhas de 7
        calendario = []
        linha = []
        primeira_semana_vazia = (primeiro_dia.weekday() + 1) % 7
        for _ in range(primeira_semana_vazia):
            linha.append(" ")
        for dia in dias_mes:
            linha.append(f"{dia.day:02d}")
            if len(linha) == 7:
                calendario.append(linha)
                linha = []
        if linha:
            while len(linha) < 7:
                linha.append(" ")
            calendario.append(linha)

        # Exibe o calend√°rio
        for semana in calendario:
            cols = st.columns(7)
            for i, dia_label in enumerate(semana):
                if dia_label.strip() == "":
                    cols[i].write(" ")
                    continue

                dia_int = int(dia_label)
                dia_str = f"{ano_atual}-{mes_atual:02d}-{dia_int:02d}"

                # OTIMIZA√á√ÉO: Lookup direto no dicion√°rio
                registros_existentes = registros_mes.get(dia_str, [])

                # Determina status e s√≠mbolo
                # O dia s√≥ mostra indicador se houver registros, mas NUNCA fica bloqueado
                symbol = ""

                if registros_existentes:
                    # Filtra apenas registros n√£o rejeitados
                    registros_ativos = [r for r in registros_existentes if
                                        (r.get("STATUS") or "").lower() != "rejeitado"]

                    if registros_ativos:
                        # Verifica se tem pendentes ou aprovados
                        status_val = [r.get("STATUS") for r in registros_ativos if r.get("STATUS")]
                        if any(s.lower() == "pendente" for s in status_val):
                            symbol = "‚è≥"
                        else:
                            symbol = "‚úÖ"
                    else:
                        # Todos foram rejeitados
                        symbol = "‚ùå"

                # Bot√£o do dia - NUNCA desabilitado, sempre clic√°vel
                if cols[i].button(f"{symbol} {dia_label}", key=f"btn_{dia_str}"):
                    st.session_state["data_selecionada"] = dia_str
                    st.session_state["form_aberto"] = True
                    # Limpa a opera√ß√£o selecionada para for√ßar nova sele√ß√£o
                    if "operacao_selecionada" in st.session_state:
                        del st.session_state["operacao_selecionada"]

        # Formul√°rio de registro
        if st.session_state.get("form_aberto") and st.session_state.get("data_selecionada"):
            dia_str = st.session_state["data_selecionada"]
            st.divider()
            st.subheader(f"üìù Registrar ve√≠culos ‚Äî {dia_str}")

            col1, col2 = st.columns(2)
            if razao_permitida != "TODOS":
                col1.info(f"üè¢ Raz√£o Social: **{razao_permitida}**")
                razao_social = razao_permitida
            else:
                razao_social = col1.selectbox("Raz√£o Social", razoes_sociais, key=f"razao_{dia_str}")

            operacao = col2.selectbox("Opera√ß√£o", operacoes, key=f"oper_{dia_str}")

            # VERIFICA√á√ÉO DE DUPLICATA ao selecionar opera√ß√£o
            tem_duplicata, registros_dup = verificar_duplicata(razao_social, dia_str, operacao)

            if tem_duplicata:
                st.warning(f"‚ö†Ô∏è J√° existe registro **{operacao}** para esta data:")
                with st.expander("üëÅÔ∏è Ver registros existentes"):
                    for reg in registros_dup:
                        status_emoji = {"Pendente": "‚è≥", "Aprovado": "‚úÖ", "Rejeitado": "‚ùå"}.get(reg.get("STATUS"), "")
                        st.markdown(
                            f"{status_emoji} **{reg.get('MODALIDADE')}**: {reg.get('QUANTIDADE')} unidades - Status: {reg.get('STATUS')}")

                st.info("üí° Selecione outra opera√ß√£o ou solicite a rejei√ß√£o do registro existente.")
                st.stop()

            # Quantidade de ve√≠culos
            st.markdown("**Quantidade de Ve√≠culos**")
            quantidades = {}
            for i in range(0, len(tipos_veiculos), 3):
                cols_q = st.columns(3)
                for j, veiculo in enumerate(tipos_veiculos[i:i + 3]):
                    quantidades[veiculo] = cols_q[j].number_input(
                        veiculo, min_value=0, step=1, key=f"{veiculo}_{dia_str}_{operacao}"
                    )

            observacoes = st.text_area("üìã Observa√ß√µes (opcional)", key=f"obs_{dia_str}_{operacao}")

            if st.button("‚úÖ Registrar", key=f"submeter_{dia_str}_{operacao}"):
                # Validar quantidades
                valido, msg_erro = validar_quantidades(quantidades)
                if not valido:
                    st.error(msg_erro)
                    st.stop()

                # Preparar registros
                registros_para_inserir = []
                data_registro = datetime.now().isoformat()

                for veiculo, qtd in quantidades.items():
                    if qtd and qtd > 0:
                        registros_para_inserir.append({
                            "RAZAO_SOCIAL": razao_social,
                            "DATA_OFICIAL": dia_str,
                            "DATA_DE_REGISTRO": data_registro,
                            "MODALIDADE": veiculo,
                            "QUANTIDADE": int(qtd),
                            "OPERACAO": operacao,
                            "STATUS": "Pendente",
                            "APROVADOR": None,
                            "DATA_DA_APROVACAO": None,
                            "MOTIVO_REJEICAO": None,
                            "OBSERVACOES": observacoes,
                            "USUARIO_REGISTRANTE": usuario_logado
                        })

                # Inserir em batch
                sucesso, mensagem = inserir_registros_batch(registros_para_inserir)

                if sucesso:
                    st.success(mensagem)
                    st.session_state["form_aberto"] = False
                    st.session_state["data_selecionada"] = None
                    st.balloons()
                    st.rerun()
                else:
                    st.error(mensagem)

# ---------------- ABA RELAT√ìRIO ----------------
if "Relatorio" in tab_dict:
    with tab_dict["Relatorio"]:
        st.title("üìä Relat√≥rio de Registros")

        st.markdown("**Selecione o per√≠odo desejado:**")
        hoje = datetime.now()
        default_start = hoje.replace(day=1)
        default_end = hoje

        periodo = st.date_input(
            "üìÖ Per√≠odo",
            value=(default_start, default_end),
            min_value=datetime(2025, 1, 1),
            max_value=datetime(2030, 12, 31),
            help="Selecione a data inicial e final do per√≠odo"
        )

        if isinstance(periodo, tuple) and len(periodo) == 2:
            data_inicio, data_fim = periodo
            if data_inicio > data_fim:
                st.error("‚ùå A data inicial n√£o pode ser maior que a final.")
            else:
                query = supabase.table("registro_veiculos_calendario").select("*")

                if razao_permitida != "TODOS":
                    query = query.eq("RAZAO_SOCIAL", razao_permitida)

                query = query.gte("DATA_OFICIAL", data_inicio.isoformat()) \
                    .lte("DATA_OFICIAL", data_fim.isoformat()) \
                    .eq("STATUS", "Aprovado")

                try:
                    res = query.execute()
                    registros = res.data
                except Exception as e:
                    logger.error(f"Erro ao buscar relat√≥rio: {e}")
                    st.error(f"‚ùå Erro ao buscar dados: {e}")
                    registros = []

                if registros:
                    df = pd.DataFrame(registros)
                    st.success(f"‚úÖ {len(df)} registros encontrados!")

                    # M√©tricas resumidas
                    col1, col2, col3 = st.columns(3)
                    col1.metric("üì¶ Total de Ve√≠culos", df["QUANTIDADE"].sum())
                    col2.metric("üè¢ Raz√µes Sociais", df["RAZAO_SOCIAL"].nunique())
                    col3.metric("üìÖ Dias com Registro", df["DATA_OFICIAL"].nunique())

                    st.dataframe(df, use_container_width=True)


                    @st.cache_data
                    def convert_df_to_excel(dataframe):
                        output = io.BytesIO()
                        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                            dataframe.to_excel(writer, index=False, sheet_name='Registros')
                        return output.getvalue()


                    excel_bytes = convert_df_to_excel(df)
                    st.download_button(
                        label="üì• Baixar relat√≥rio em Excel",
                        data=excel_bytes,
                        file_name=f"relatorio_{data_inicio}_{data_fim}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    )
                else:
                    st.info("‚ÑπÔ∏è Nenhum registro aprovado encontrado para o per√≠odo selecionado.")

# ---------------- ABA FLUXO DE APROVACAO ----------------
if "Fluxo de Aprovacao" in tab_dict:
    with tab_dict["Fluxo de Aprovacao"]:
        st.title("üîÑ Fluxo de Registros")

        st.markdown("**Filtrar por per√≠odo e status:**")
        hoje = datetime.now()
        periodo = st.date_input(
            "üìÖ Per√≠odo",
            value=(hoje.replace(day=1), hoje),
            min_value=datetime(2025, 1, 1),
            max_value=datetime(2030, 12, 31)
        )

        if len(periodo) == 2:
            data_inicio, data_fim = periodo
        else:
            data_inicio = data_fim = periodo[0]

        status_filtro = st.selectbox("üîç Status", ["Todos", "Pendente", "Aprovado", "Rejeitado"])

        query = supabase.table("registro_veiculos_calendario").select("*") \
            .gte("DATA_OFICIAL", data_inicio.isoformat()) \
            .lte("DATA_OFICIAL", data_fim.isoformat())

        if razao_permitida != "TODOS":
            query = query.eq("RAZAO_SOCIAL", razao_permitida)
        if status_filtro != "Todos":
            query = query.eq("STATUS", status_filtro)

        try:
            registros = query.execute().data or []
        except Exception as e:
            logger.error(f"Erro ao buscar fluxo: {e}")
            st.error(f"‚ùå Erro: {e}")
            registros = []

        if registros:
            df = pd.DataFrame(registros)

            # M√©tricas
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("üìã Total", len(df))
            col2.metric("‚è≥ Pendentes", len(df[df["STATUS"] == "Pendente"]))
            col3.metric("‚úÖ Aprovados", len(df[df["STATUS"] == "Aprovado"]))
            col4.metric("‚ùå Rejeitados", len(df[df["STATUS"] == "Rejeitado"]))

            st.dataframe(df, use_container_width=True)
        else:
            st.info("‚ÑπÔ∏è Nenhum registro encontrado para o filtro selecionado")

# ---------------- ABA APROVACAO ----------------
if "Aprovacao" in tab_dict:
    if usuario_logado in usuarios_aprovacao_somente or razao_permitida == "TODOS":
        with tab_dict["Aprovacao"]:
            st.title("‚úÖ Aprova√ß√£o de Registros")

            hoje = datetime.now()
            periodo = st.date_input(
                "üìÖ Per√≠odo",
                value=(hoje.replace(day=1), hoje),
                min_value=datetime(2025, 1, 1),
                max_value=datetime(2030, 12, 31)
            )

            if len(periodo) == 2:
                data_inicio, data_fim = periodo
            else:
                data_inicio = data_fim = periodo[0]

            query = supabase.table("registro_veiculos_calendario").select("*") \
                .eq("STATUS", "Pendente") \
                .gte("DATA_OFICIAL", data_inicio.isoformat()) \
                .lte("DATA_OFICIAL", data_fim.isoformat()) \
                .order("DATA_OFICIAL", desc=False)

            try:
                registros = query.execute().data or []
            except Exception as e:
                logger.error(f"Erro ao buscar aprova√ß√µes: {e}")
                st.error(f"‚ùå Erro: {e}")
                registros = []

            if registros:
                st.success(f"‚è≥ {len(registros)} registros pendentes de aprova√ß√£o")

                for i, registro in enumerate(registros):
                    with st.expander(
                            f"üì¶ {registro['RAZAO_SOCIAL']} | {registro['DATA_OFICIAL']} | {registro['OPERACAO']} | {registro['MODALIDADE']} | {registro['QUANTIDADE']} unidades"
                    ):
                        col_info1, col_info2 = st.columns(2)
                        col_info1.markdown(f"**üè¢ Raz√£o Social:** {registro['RAZAO_SOCIAL']}")
                        col_info1.markdown(f"**üìÖ Data:** {registro['DATA_OFICIAL']}")
                        col_info1.markdown(f"**üöó Modalidade:** {registro['MODALIDADE']}")

                        col_info2.markdown(f"**üî¢ Quantidade:** {registro['QUANTIDADE']}")
                        col_info2.markdown(f"**‚öôÔ∏è Opera√ß√£o:** {registro['OPERACAO']}")
                        col_info2.markdown(f"**üë§ Registrado por:** {registro.get('USUARIO_REGISTRANTE', '‚Äî')}")

                        obs = registro.get("OBSERVACOES")
                        if obs:
                            st.info(f"üìã **Observa√ß√µes:** {obs}")

                        st.divider()

                        col1, col2 = st.columns(2)

                        with col1:
                            if st.button("‚úÖ Aprovar", key=f"aprovar_{i}", use_container_width=True):
                                try:
                                    supabase.table("registro_veiculos_calendario").update({
                                        "STATUS": "Aprovado",
                                        "APROVADOR": usuario_logado,
                                        "DATA_DA_APROVACAO": datetime.now().isoformat(),
                                        "MOTIVO_REJEICAO": None
                                    }).eq("id", registro["id"]).execute()

                                    st.success("‚úÖ Registro aprovado com sucesso!")
                                    st.rerun()
                                except Exception as e:
                                    logger.error(f"Erro ao aprovar: {e}")
                                    st.error(f"‚ùå Erro ao aprovar: {e}")

                        with col2:
                            if st.button("‚ùå Rejeitar", key=f"rejeitar_{i}", use_container_width=True):
                                st.session_state[f"rejeitando_{i}"] = True

                        # Formul√°rio de rejei√ß√£o
                        if st.session_state.get(f"rejeitando_{i}", False):
                            motivo = st.text_area(
                                "üìù Motivo da rejei√ß√£o (obrigat√≥rio)",
                                key=f"motivo_{i}",
                                placeholder="Descreva o motivo da rejei√ß√£o..."
                            )

                            col_confirm, col_cancel = st.columns(2)

                            with col_confirm:
                                if st.button("Confirmar Rejei√ß√£o", key=f"confirmar_rej_{i}", type="primary"):
                                    if not motivo or motivo.strip() == "":
                                        st.error("‚ùå O motivo da rejei√ß√£o √© obrigat√≥rio!")
                                    else:
                                        try:
                                            supabase.table("registro_veiculos_calendario").update({
                                                "STATUS": "Rejeitado",
                                                "APROVADOR": usuario_logado,
                                                "DATA_DA_APROVACAO": datetime.now().isoformat(),
                                                "MOTIVO_REJEICAO": motivo
                                            }).eq("id", registro["id"]).execute()

                                            st.success("‚úÖ Registro rejeitado com sucesso!")
                                            st.session_state[f"rejeitando_{i}"] = False
                                            st.rerun()
                                        except Exception as e:
                                            logger.error(f"Erro ao rejeitar: {e}")
                                            st.error(f"‚ùå Erro ao rejeitar: {e}")

                            with col_cancel:
                                if st.button("Cancelar", key=f"cancelar_rej_{i}"):
                                    st.session_state[f"rejeitando_{i}"] = False
                                    st.rerun()
            else:
                st.info("‚ÑπÔ∏è Nenhum registro pendente de aprova√ß√£o no per√≠odo selecionado.")
